package ex1_string;


public class Ex1_String {

	public static void main(String[] args) {
		
		/* CLASS
		 CLASS를 생성할 때는 기존의 클래스 명칭(String, Random, Scanner)으로 사용하면 클래스가 덮어쓰기되니 명칭은 꼭 구분하여 클래스를 생성하자
		 
		 String
		 String은 두가지 특징이 있다.
		 1) 객체 생성법이 두가지가 있다. (암시적, 명시적)
		 2) 한 번 생성된 문자열의 내용은 변하지 않는다. (불변적 특징)
		 
		 객체
		 클래스(Scanner, String(객체형 변수))로 생성한 변수는 객체라고 부른다.
		 배열로 생성하는 변수도 객체(heap 메모리에 영역을 생성하는)라고 부른다. 
		 
		 */
		
		// 암시적 객체 생성
		// 기존에 생성된 값과 같은 데이터를 갖고자하는 객체간 주소를 공유하는 방식
		
		// 예) s1이라는 객체는 "abc"라는 heap영역의 데이터에 접근할 수 있도록 주소값을 stack에 가지고있다.
		// s2에 값을 입력하려고 할 때, jvm은 heap영역을 한 번 검토하게되는데 이 때 s1과 s2는 같은 값을 저장하므로 s1과 s2의 주소가 같아진다. 
		String s1 = "abc";
		String s2 = "abc";
		
		// new를 사용하여 생성할시 명시적 클래스(명시적 객체 생성)가 된다.
		// 명시적 객체 : 기존 heap메모리에 추가되어있는 데이터는 상관없이 무조건 새로운 영역을 생성하는 방식
		String s3 = new String("abc");
		
		// 위와 같이 s2처럼 s1의 데이터를 참조하는 객체를 암시적 객체 생성이라고 한다.
		
		// 위 둘의 주소가 같은지 확인
		// (중요!) == 연산자는 객체간의 비교에서는 주소값을 비교한다. (변수에서의 비교는 값만 비교한다.) 
		if(s1==s2) {
			System.out.println("주소가 같습니다.");
		}else {
			System.out.println("주소가 다릅니다.");
		}
		
		System.out.println("---------------");
		
		// Scanner에서 'abc'에서 받아 변수에 저장하여 비교해보니 객체간에 주소가 다르다고 나온다.
		// 값이 다른데 왜 주소가 달라지는가?
		if(s1==s3) {
			System.out.println("주소가 같습니다.");
		}else {
			System.out.println("주소가 다릅니다.");
		}
		
		// 답 : 명시적 객체 생성은 메모리에 같은 값을 가지고있는 데이터가 있든 없던 new가 있으므로 같은 데이터를 heap영역에 새로 만든다.
		// 그래서 주소값이 다르기 때문에 if문에서 주소값을 비교하여 다르다는 결과값이 나오는 것이다. 
		// 즉, String 클래스는 ==을 통해서 값을 비교하는 경우는 거의 없다.
		
		
		System.out.println("---------------");
		/* String 클래스는 주소 비교가 아닌 값 비교를 하는 경우가 대부분이므로, == 대신 equals()라는 기능을 사용한다. 
		 * equals는 같은지 같지 않은지를 boolean타입으로 반환한다. (그래서 if의 조건식에 들어갈 수 있다.)*/
		
		// 객체는 .을 통해서 내부 접근이 가능하다.
		// .을 통해서 내부 접근하여 사용하는 기능을 메서드라고 한다.
	
		if(s1.equals(s3)) {
			System.out.println("s1과 s3의 값이 같습니다.");
		}
		
		System.out.println("---------------");
		/* 두번째 특징 */
		String greet = "안녕";
		greet += "하세요.";
		System.out.println(greet);
		
		// 한번 만들어진 heap의 안녕이라는 데이터는 절대 변하지 않는다.
		// 그래서 합쳐주기위해서 heap 영역에 합쳐진 상태의 데이터를 heap영역에 생성하여 이 주소값을 전달한다. (주소의 이전)
		// 그럼 기존의 '안녕'이 들어있던 데이터 영역은 jvm에 들어있는 가비지 컬렉터에 저장된다. (가비지 컬렉터는 계속해서 메모리(heap영역)를 돈다. 
		// 그런데, 만약 new로 생성되는 것이 가비지 컬렉터의 수집 속도보다 빠르면 오류가 날 수 있다. 
		
		
		
	}
}
