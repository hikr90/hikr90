package ex1_operator;

public class Ex3_Operator {
	public static void main(String[] args) {
		// 비트 연산자와 시프트 연산자는 정보보안 분야에서 많이 사용한다. (웹개발은 거의 사용하지 않을 수도 있음)
		// 비트 연산자 : 논리연산자와 유사하지만 bit단위(2진수)의 연산만 가능하다.
		// 결과값이 정수값으로 반환된다.
		int a = 10; // 2진수 : 1010
		int b = 7; // 2진수 : 0111
		
		// 논리곱(and) 
		// c는 1010과 0111을 곱한 값으로, 논리곱은 둘다 1인 경우 1이고 나머지는 0이다.
		// 즉 0010이 나오는데 이는 2와 같은 값이다.
		int c = a & b;
		System.out.println("논리곱 : " + c);
	
		// 논리합(or)
		// 2진수로 변경시, 두 값이 모두 0일 때만 결과가 0 나머지는 1이다. 
		// 즉 1111은 15가 된다.
		c = a | b;
		System.out.println("논리합 : " + c);
		
		// 베타적or(xor)
		// 2진수로 변경 시, 두 값이 같으면 0, 다르면 1 이다.
		// 즉 1101로 13이 된다. 
		c = a ^ b;
		System.out.println("베타적or : " + c);
		
		System.out.println("------------------");
		
		// 시프트 연산자 : 2진수 단위의 연산을 진행, bit단위의 연산을 수행하되, 왼쪽 또는 오른쪽으로 이동시켜 값에대한 변화를 주는 연산자
		// 1100이 왼쪽으로 001100이 되는데, 뒤의 00은 잘려서 0011이 되어 3이 나온다.
		int n1 = 12; //2진수 : 1100
		int n2 = n1 >> 2; 
		System.out.println("비트연산 : " + n2);

		char ch = 'F'; // F는 70으로 16진수시 : 1000110
		char ch_res = (char)(ch >> 1); // 좌로 이동시 : 0100011
		// 디모션 캐스팅을 통해서 문자 자료형으로 두었기에 아스키코드의 35숫자에 해당하는 #으로 출력이 된다. 
		System.out.println("비트연산 : " + ch_res);
		
		/* 만약 35로 출력하고싶다면 int에 담아서 출력하면 된다.
		int char_res = ch >> 1; 
		System.out.println(char_res);*/
	}
}



