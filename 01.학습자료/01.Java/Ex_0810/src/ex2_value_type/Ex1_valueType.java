package ex2_value_type;

public class Ex1_valueType {
	public static void main(String[] args) {
		
		/* 자료형
		 * 	- 자료형은 기본형과 참조형으로 구분된다.
		 * 	- 기본형 변수는 실제 값을 저장하는데 반면, 참조형 변수는 어떤 값이 저장된 주소 값을 가진다.
		 * 	- 자바에서 참조형 변수는 변수간의 연산이 불가능하므로 기본 자료형만 실제 연산에 사용된다.
		 * 
		 * 	(1) 기본 자료형
		 * 		(1.1) 정수형
		 * 			byte
		 * 				- 표현범위 : -128 ~ 127
		 * 				- 1byte로 정수를 표현하는 자료형			
		 * 
		 * 			short
		 * 				- 표현범위 : -32768 ~ 32767
		 * 				- 2byte로 정수를 표현하는 자료형
		 * 				
		 * 			int (default)
		 * 				- 표현범위 : -21억 ~ 21억
		 * 				- 4byte로 정수를 표현하는 자료형
		*					- 정수형 중 cpu에서 가장 효율적으로 처리할 수 있는 타입
		 * 
		 * 			long
		 * 				- 표현범위 : -900경 ~ 900경
		 * 				- 8byte로 정수를 표현하는 자료형
		 * 	
		 * 		(1.2) 실수형 (3.14 등..)
		 * 			float
		 * 				- 표현범위 : 없음
		 * 				- 4byte로 실수를 표현하는 자료형
		 * 				- 10진수의 7자리까지만 (소수점 이하 6째자리) 표현하므로 7번째 자리에서 반올림되어 표현된다.
		 * 				- 반올림 이후 자리의 숫자는 0으로 오차가 발생하여 저장된다. 
		 * 
		 * 			double (default)
		 * 				- 표현범위 : 없음
		 * 				- 8byte로 실수를 표현하는 자료형
		 * 				- 실수형은 정수형과 다르게 값의 오차가 발생할 수 있어 값의 정밀도가 중요하다.
		 * 				- 실수형의 기본 값이 double인 이유는 float이 값이 정밀도가 10진수의 7자리까지인데 비해 double은 10진수의 15자리의 정밀도를 가지기 때문이다.
		 * 				- (double의 의미는 float보다 값의 정밀도를 2배 정도 가진다는 뜻이다.)
		 * 
		 * 		(1.3) 문자형
		 * 			char
		 * 				- 표현 범위 : 0 ~ 65535
		 * 				- 2byte로 문자를 표현하는 자료형
		 * 				- 'A' 혹은 'a' 등 '' 안에 한 글자로만 구성된 문자
		 * 				- 문자 값은 실제로 메모리에는 'A'의 형태가 아닌, 문자의 유니코드 ('A'의 경우 정수값인 65) 의 형태로 저장된다.
		 * 				- 문자의 유니코드 값을 확인하고자하는 경우 앞에 (int)를 붙여서 정수형으로 출력하면 확인이 가능하다.
		 * 				- \n, \t 등의 개행문자의 형태로 저장하여 사용할 수 도 있다.
		 * 
		 * 				[참고] 유니코드
		 * 					- 다른 언어를 사용하는 지역 간 컴퓨터 간 문서 교환의 어려움을 해소하기위해서 만들어진 문자 집합
		 * 					- 유니코드의 문자들의 집합은 유니코드 문자 셋, 혹은 캐릭터 셋 (character set) 이라고 부른다.
		 * 					- 이 문자 셋에 번호를 붙인 것을 유니코드 인코딩이라고 부르는데, UTF-8, UTF-16, UTF-32 등이 포함된다.
		 * 					- 자바에서는 UTF-16을 사용하고 있다.
		 * 					
		 * 					- UTF-16 : 모든 문자를 2byte의 고정 크기로 표현, 아스키를 그대로 포함하고 있다.
		 * 					- UTF-8 :  모든 문자를 1~4byte의 가변 크기로 표현, 아스키를 그대로 포함하고 있다.
		 * 
		 * 					- 고정 크기인 UTF-16이 관리하기에 용이하나, 1byte인 영어와 숫자가 2byte로 저장되므로 문서가 크고
		 * 					- 한글의 경우, 3byte이므로 문자의 크기가 가변적이여서 다루기 어렵다는 단점이 있다.
		 * 					- 인터넷에서는 문서의 크기가 작을 수록 유리하므로 UTF-8으로 작성된 웹문서의 수가 증가하고 있다.
		 * 
		 *	 				[참고] bit 의 범위
		 *						- 1byte는 8bit이다.
		 *						- 비트의 범위를 구하는 2의 n승 - 1로 1byte의 표현 범위는 -128 ~ 127 이다.
		 *						- 최대 값에서 1이 빠지는 이유는 범위에 0이 포함되기 때문이다.
		 *
		 * 					- char는 2byte로 16bit에 해당된다.
		 * 					- 16자리의 2진수로 표현할 수 있는 정수의 개수 65536개 (2의 16승) 의 코드를 사용가능하다.
		 * 					- 단, 유니코드의 경우 음수를 표현할 필요가 없으므로 short과 표현 범위가 다르다.
		 * 					
		 * 					- char : 0 ~ 65535
		 * 					- short : -32768 ~ 32767
		 * 
		 * 
		 * 				[참고] 인코딩 & 디코딩
		 * 					- 인코딩 : 문자를 코드로 변환하는 작업 (유니코드)
		 * 					- 디코딩 : 코드를 문자로 변환하는 작업
		 * 					- 실제로 char 형태의 값이 저장될 때는 문자가 인코딩되어 코드로 저장이되고, syso를 통해서 다시 출력할 때는 디코딩되어서 문자로 출력되는 것이다.
		 * 
		 *			(1.4) 논리형
		 *				boolean
		 *					- 표현범위 : true 혹은 false
		 *					- 1bit로 표현하는 참 혹은 거짓 값 
		 *
		 *		(2) 클래스 자료형
		 *			- 객체의 주소를 저장하는 8개의 기본형을 제외한 나머지 타입
		 *			- 참조변수는 null 또는 객체의 주소를 값으로 가진다.
		 *
		 *			String
		 *				- 첫 글자가 대문자인 자료형이 클래스 자료형에 속한다.
		 *				- Date 클래스나 empVO 클래스가 이에 해당한다. (참조변수는 타입으로 클래스의 이름을 사용한다.)
		 *				- 엄밀히 자료형이 아니지만 통상적으로 자료형이라 부르며 String 값은 아무 값도 들어가지 않는 경우 ""으로 초기화하게 된다.
		 *
		 *				[참고] String은 참조변수 중 예외적으로 new String("Java"); 의 방식으로도 객체 선언이 가능하다.
		 *				
		 *				- 표현범위 : 표현하는 만큼
		 *				-  "ABC" 혹은 "가나다" 같은 문자열
		 */
		
		/*	변수 
		 * 	- 단 하나의 값을 대입하여 저장하기위한 공간 (새로운 값이 들어오는 순간 기존의 값은 사라진다.)
		 * 	- 선언과 초기화 작업을 통해서 생성 및 저장할 준비를 한다.
		 * 	
		 * 	(1) 선언 규칙
		 * 		- 변수명은 클래스와 혼동되지 않도록 	대문자나 숫자로 시작하면 안되며 대소문자를 구분한다.
		 * 		- 특수문자는 _ 과 $만을 허용한다.
		 * 		- 한글로 변수명을 짓지 않는다.
		 * 		- 동일한 명칭의 변수명은 사용할 수 없다.
		 * 		- 예약어 (프로그래밍 구문에 사용되는 언어, default, static, super, true 등..) 를 사용해서는 안된다.
		 * 		- 명칭은 개발자 간 서로 쉽게 이해할 수 있도록 의미가 있는 단어로 작성한다.
		 * 
		 * 	(2) 사용 이유
		 * 		- 반복되는 값을 간단하게 관리하기 위해서.
		 * 		- 다른 사람이 봤을 때 이해가 쉽도록.
		 * 
		 * 	(3) 표현 방식
		 * 		- Camel Case 형태로 많이 사용한다.
		 * 		- 기본적으로 소문자로 작성하되, 첫글자는 대문자 나머지 글자는 소문자로 작성하는 형태이다.
		 * 		- 예시로 empNm, sendData등이 해당된다.
		 * 
		 * 	[참고] 컴퓨터 구조에서의 변수
		 *			- int x = 10; 는 컴퓨터 내 ram에 x라는 저장공간이 생성되고 그 안에 10이라는 숫자 값이 저장됨을 뜻한다. 
		 */
		
		// 변수의 선언, 대입, 초기화
		// 1. 숫자형
		int a1;
		
		// 대입
		a1 = 21000;
		
		// 초기화
		// - 변수를 사용하기 전에 처음으로 값을 지정하는 것 (변수의 선언과 대입이 동시에 이루어지는 형태)
		// - 변수는 사용하기 전에 반드시 초기화 하는 것이 좋다. (프로그램 내 가비지 값이 남아있을 수 있기에)
		// - 변수의 초기화는 중복으로 사용할 수 없으며 같은 명칭의 변수에 값을 대입하는 것으로 사용한다.
		// - 대입할 경우 기존의 값은 없어지고 대입한 값이 저장된다.
		int a2 = 21000;
		
		// 2. 논리형
		boolean b = true;
		System.out.println("b : " + b);
		
		b = false;
		System.out.println("b : " + b);
		
		System.out.println("-------------------------------");
		
		// 3. 문자형
		char c = 'A';
		System.out.println("c : " + c);
		
		c = 'B';
		System.out.println("c : " + c);
		
		// (예시) 아스키코드
		// - 미국 국립 표준 협회 (ANSI) 에서 표준화한 정보교환용 7비트 부호체계
		// - 정보 교환 시, 통일성을 위해서 만들어졌다.
		// - 문자형의 변수에 67이라는 10진법의 숫자를 16진법으로 변환하여 문자로 표현한다.
		c = 68;
		System.out.println("c : " + c);
		
		System.out.println("-------------------------------");

		// 4. 정수형
		byte by = 127; 
		int n = 2100000000;
		
		/*	long과 float 사용 시 주의사항
		 *		- jvm에서 변수에 값이 저장될 때 확인을 위해서 메모리를 사용하는데 값이 저장될 때마다 메모리가 낭비되는 것을 막기위해서
		 *		- 즉 컴파일 속도 향상을 위해서 int값을 기본 값으로 인식하도록 되어있다.
		 *
		 * 	- 그러므로 long 타입의 변수가 2100000000을 저장하는 경우 기본형인 int로 판단하여 값이 벗어났다고 인식하여 오류를 발생시킨다.
		 * 	- 그래서 int 범위가 넘어가는 21억 이상의 값을 저장할 때는 값 뒤에 l을 붙여서 해당 값이 long이라고 명시를 해야한다.
		 */		
		long lo = 2200000000l;	// long 타입임을 명시 (리터럴)
		System.out.println("by : " + by);
		System.out.println("lo : " + lo);
		System.out.println("n : " + n);
		
		System.out.println("-------------------------------");
		
		// 5. 실수형
		float f = 3.14f;		// float 타입임을 명시 (리터럴)
		double d = 3.14;	// double의 경우 실수형에서의 기본자료형이라 d를 생략해도 무방하다.
		
		// 실수형은 정수값이 입력되는 경우, 자동으로 .0을 붙여서 오류가 나지 않도록 한다.
		f = 150;
		d = 150;
		System.out.println("f : " + f);
		System.out.println("d : " + d);		
		}
}
