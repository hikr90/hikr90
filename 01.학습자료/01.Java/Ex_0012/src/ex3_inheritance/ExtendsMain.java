package ex3_inheritance;

public class ExtendsMain {
	
	public static void main(String[] args) {
		
		/*	상속 (inheritance) 
		 * 	- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.
		 * 	- 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성을 높인다.
		 * 
		 * 		부모 클래스
		 * 			- 자식 클래스에게 멤버 등의 값을 상속하는 클래스
		 * 			- 조상 클래스, 상위 클래스, 슈퍼 클래스라고도 한다.
		 * 		
		 * 		자식 클래스
		 * 			- 부모의 멤버 등의 값을 상속받는 클래스
		 * 			- 자손 클래스, 하위 클래스, 서브 클래스라고도 한다.
		 * 	
		 * 		작성 방법	
		 * 			class 자식 클래스 명칭 extend 부모 클래스 명칭 { 
		 * 				작성 내용
		 * 			} 
		 * 
		 * 	장점 & 단점
		 * 		- 객체의 공통적인 속성을 사용하는 경우, 부모 자식간 속성을 그대로 가져다 사용할 수 있다는 장점이 있으나
		 * 		- 자식은 단 하나의 부모만 상속이 가능하다는 단점이 있다. (두가지 부모 상속 시, 양 부모에 동일한 속성이 있는 경우, 특정 속성으로 구분하여 명시할 수 없으므로 불가)
		 *  
		 *  	특정
		 *  		(1) 자식 클래스에 추가되는 멤버는 부모 클래스에 어떠한 영향도 주지 못한다.
		 *  		(2) 생성자와 초기화 블럭은 상속되지 않는다.
		 *  		(3) 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
		 *  		(4) 부모 클래스의 private 등의 제어자는 상속은 되나, 자식 클래스로부터의 접근이 제한된다.
		 *  		(5) 같은 부모 클래스를 상속하는 두 자식 클래스는 서로 어떠한 관계도 없다.
		 *  		(6) 자식 클래스의 인스턴스 생성 시 부모 클래스의 멤버와 자식 클래스의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
		 *  	
		 *  	상속 관계의 객체와
		 *  		(1) 자식
		 *  			- Object > 부모 > 자식
		 *  			- 자식과 부모의 주소 값은 동일하다.
		 *  
		 *  		(2) 부모
		 *  			- Object > 부모 
		 *  			- 자식과 부모의 주소 값은 동일하지 않다.
		 *
		 *			상속의 순서
		 *				(1)  객체 생성 (new) 시 Object 클래스에 heap 영역 할당
		 *				(2) 부모 클래스 영역, 데이터 생성
		 *				(3) 부모 클래스 주소 값을 통해서 자식 클래스의 영역 할당
		 *				(4) 자식 클래스 영역, 데이터 생성
		 *
		 *			클래스간의 포함 관계
		 *				- 한 클래스의 멤버 변수로 다른 클래스 타입의 참조 변수를 선언하는 것.
		 *				- 예시) 자동차 클래스 내 엔진, 문 등의 여러가지 클래스 선언하여 각각의 클래스의 멤버 값을 사용
		 *						class Car {
		 *							Engine e = new Engine();
		 *							Door [] d = new Door[4];
		 *						} 
		 *
		 *				- 클래스 간 상속, 포함의 관계 여부는 양 클래스가 ~ 은 ~ 이다. (상속) 혹은 ~은 ~을 가지고 있다 (포함) 로 구분한다.
		 *
		 *			참조변수와 인스턴스 연결
		 *				- 부모 클래스에서 선언된 멤버 변수와 같은 이름의 인스턴스 변수가 자식 클래스에서 중복으로 정의되었을 때 
		 *				- 부모 타입의 참조변수로 자식 인스턴스를 참조하는 경우와 자식 타입의 참조변수로 자식 타입의 인스턴스를 참조하는 경우는 서로 다른 결과가 나온다.
		 *
		 *				(1) 참조변수
		 *					(1.1) 부모 타입의 참조변수인 경우, 부모 클래스에 사용된 멤버변수가 사용된다.
		 *					(1.2) 자식 타입의 참조변수인 경우, 자식 클래스에 사용된 멤버변수가 사용된다.
		 *
		 *				(2) 메소드
		 *					- 부모, 자식 클래스에서 메소드가 오버라이딩되는 경우에도 참조 타입과 상관없이 실제 인스턴스 메소드 (자식의 오버라이딩 메소드) 가 불러와진다.
		 *					- static 메소드는 static 변수처럼 참조변수의 타입에 영향을 받는다. (그래서 static 메소드는 참조변수가 아닌 클래스.메소드() 로 불러와야한다.)
		 */

		// 자식 클래스의 객체화
		Child c = new Child();
		System.out.println(c.money);
		System.out.println(c.car);
		
		// instanceof 메소드를 통해서 좌측 객체가 우측 클래스의 자식인지를 확인 (주소 값의 비교)
		// 상속 관계에서는 부모 자식, Object 간 true 값이 리턴된다. (자식은 Object의 자손 격이므로)
		if(c instanceof Parents) {
			System.out.println("c는 Parents의 자식입니다.");
		}
	
		System.out.println("-------------------");
		
		// 부모 클래스의 객체화
		// - 상속관계의 객체라고 할지라도 부모는 자식의 필드(속성)를 마음대로 사용할 수 없다.
		Parents p = new Parents();
		
		if(c instanceof Object) {
			System.out.println("자식 클래스와 부모클래스는 object클래스에 상속되어있다.");
		}
		
		/*	Object 클래스
		 * 	- 모든 클래스 상속 계층도의 최상위에 있는 조상 클래스
		 * 	- 컴파일러는 컴파일 시, 다른 클래스로부터 상속받지 않는 모든 클래스들은 자동으로 Object 클래스로부터 상속받게 한다. (타 클래스 상속이여도, 최상위 Object 상속)
		 * 	- toString, equals 등의 메소드 사용이 자유로운 이유는 이 때문이다.
		 */
	}
}
