package ex5_volatile;

public class Ex1_Volatile {
	public static void main(String[] args) {
		/*	Volatile
		 * 		- 코어가 변수의 값을 읽어올 때, 캐시가 아닌 메모리에서 읽어오게하는 명령어
		 * 		
		 * 		[참고] 코어가 캐시의 값을 읽는 방법
		 * 			- 코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다.
		 * 			- 다시 동일한 값을 읽을 때는 먼저 캐시에 있는지 확인하고 없을 때만 메모리에서 읽어온다.
		 * 			
		 * 		- 만약 도중에 메모리에 저장된 값이 변경된 경우에는 캐시에 저장된 값이 갱신되지 않아서 메모리의 값과 달라지는 상황이 발생한다.
		 * 		- 이런 경우 변수 stopped의 값이 변경되어도 쓰레드가 멈추지 않을 수 있다.
		 * 		- 이런 상황에서 위의 명령어를 앞에 붙이게되면 코어가 값을 읽을 때 캐시가 아닌 메모리에서 읽어오게 된다.
		 * 
		 * 		[참고] volatile 대신 synchronized 블럭을 사용해도 같은 효과를 볼 수 있다.
		 * 			(synchronized 블럭으로 들어갔다 나올 때, 캐시 <> 메모리간 동기화가 이뤄지기 때문이다.)
		 * 
		 * 		[참고] 상수에는 volatile를 붙일 수 없다.
		 * 			(애초에, 상수는 변하지 않는 값으로 멀티 쓰레드에 안전하므로 명령어를 붙일 필요가 없다.)
		 * 
		 */
		
		// [참고] volatile은 변수의 읽기나 쓰기를 원자화 (작업을 더이상 나눌 수 없게 함) 할 뿐, 동기화하는 것은 아니여서 동기화를 위해서는 메소드 앞에 synchronized를 사용해야 한다.
		// volatile long balance;
		
		// synchronized int getBalance() {
		//	return balance;
		//}
	}
}
